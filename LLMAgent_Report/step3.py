# -*- coding: utf-8 -*-
"""Cyber210_Final_VulnAgent.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Bx1N-ID4RkBt-aJwTz0fhhA9s7xgq1eY
"""

from langchain_google_genai import ChatGoogleGenerativeAI
from langchain_openai import ChatOpenAI
from langgraph.graph import StateGraph, END
from typing import TypedDict, Annotated, List
import operator
from langgraph.checkpoint.sqlite import SqliteSaver
from langchain_core.messages import AnyMessage, SystemMessage, HumanMessage, AIMessage, ChatMessage
#from langchain.output_parsers import StructuredOutputParser
import os
import getpass
import re
import requests
from bs4 import BeautifulSoup

from langchain import PromptTemplate
#from langchain.document_loaders import WebBaseLoader
from langchain.schema import StrOutputParser
from langchain.schema.prompt_template import format_document
memory = SqliteSaver.from_conn_string(":memory:")


# gemini api key

# if "GOOGLE_API_KEY" not in os.environ:
#   os.environ["GOOGLE_API_KEY"] = getpass.getpass("Provide your Google API Key")

# chatgpt api key
if "OPENAI_API_KEY" not in os.environ:
   os.environ["OPENAI_API_KEY"] = getpass.getpass("Provide your OpenAI API Key")

# Things to track in the agent state
class AgentState(TypedDict):
    ip: str # target ip to scan
    nmap_results: list[str] # the cleaned results from nmap scan, softwares and versions, services
    searchsploit_queries: list[str] # queries for searchsploit to find any active exploits for each software
    cves_results: list[list[str]] # results for each software from searchsploit
    cves: str # list of CVEs
    report: str # final report
    messages: Annotated[list[AnyMessage], operator.add]

# gemini LLM agent object
# llm = ChatGoogleGenerativeAI(model="gemini-pro", convert_system_message_to_human=True)
# result = llm.invoke("Write a ballad about LangChain")
# print(result.content)


from langchain_openai import ChatOpenAI
llm = ChatOpenAI(model="gpt-3.5-turbo", temperature=0)
result = llm.invoke("Write a ballad about LangChain")
print(result.content)

# store queries
from langchain_core.pydantic_v1 import BaseModel

class Queries(BaseModel):
    queries: list[str]

# prompts for each node
#Reference the CVE database and

cve_prompt = """You are a cybersecurity analyst tasked with gathering information for a report on identifying potential vulnerabilities in a list of softwares and their versions. \
For each software, Reference the CVE database and return 5 CVEs with the highest CVSS score for each of the softwares in the list pasted below.\
In your response only include the CVE, the CVSS, the description and suggestions for remediation. \
\n\n {content}  """

searchsploit_queries_prompt = """you are a network security analyst tasked with using searchsploit to find out if any exploits exist for the list of softwares below. \
For each pair of software and its version, craft one searchsploit query per pair. Separate each query with a new line. """


write_report_prompt = """you are a cybersecurity analyst tasked with generating a report on your findings. \
Create a report with an executive summary, a short description of each CVE, recommendations for remediation and a conclusion. \
\n\n {content}  """

# helper function definitions

# ping_test (calls parse_nmap) -> pings target to see if it is reachable, if can be reached,
# then parse_nmap is called to scan and get software versions. uses -sV to get software and
# version, as well as services.

# parse_cve (calls cve_call) -> parse_cve is given LLM agent's response, parses message to pull
# cve-year-idnum. calls cve_call and passes list of parsed cves. cve_call uses api to send GET
# request for each cve, pulls ID, CVSS, Summar, and Solutions. returns list of lists.

def ping_test(ip):
  command = "ping -c 2 -W 50 "+ip
  result = os.system(command)
  if result == 0:
    print("connected")
    nmap = parse_nmap(ip)
    return nmap
  else:
    print("could not connect.\nenter a different value.")
    return ["1"]

def parse_nmap(ip):
  # add open file close file
  f = open("nmapScan.txt","w")
  f.close()
  command = "nmap -sV "+ip+" >> nmapScan.txt"
  os.system(command)
  f = open("nmapScan.txt", "r")
  nmapData = f.read()
  lines = nmapData.splitlines()
  f.close()
  os.system("head nmapScan.txt")
  services = []
  for line in lines:
    if line[:2].isnumeric():
      services.append(line)
  return services

## CHECK FUNCTIONALITY
def parse_searchsploit(cves):
  exploits = []
  for cve in cves:
    url = f"https://www.exploit-db.com/search?q={cve}"
    response = requests.get(url)
    print("EXPLOIT CVE: ", response)
    if response.status_code == 200:
      soup = BeautifulSoup(response.content, 'html.parser')
      exploit_links = []
      results = soup.find_all('div', class_='exploit-list')
      for res in results:
        links = res.find('a', class_='exploit-link')
        if links:
          exploit_links.append(links.get('href'))
      exploits.append(len(exploit_links))
    else:
      print("CVE not found")
      return[]

  return exploits

def parse_cve(prompt):
  cves = []
  lines = prompt.strip().split('\n')
  for line in lines:
    match = re.search(r'CVE-\d{4}-\d{4,7}', line)
    if match:
      cve = match.group()
      cves.append(cve)
  cve_res = cve_call(cves)
  return cves, cve_res

def cve_call(cves):
  details = [] # list of lists of strings.
  for cve in cves:
    cve_id = str(cve)
    url = f"https://vulnerability.circl.lu/api/cve/{cve_id}"
    response = requests.get(url)
    print("\nCVE API CALL ", cve_id, "  STATUS CODE ", response.status_code)
    if response.status_code == 200:
      try:
        data = response.json()
        #print(data)
        per_cve = []
        per_cve.append(data["cveMetadata"]["cveId"])
        #per_cve.append(data.get("cvss"))
        per_cve.append(data["containers"]["cna"]["descriptions"][0]["value"])
        #per_cve.append(data.get("solutions"))
        details.append(per_cve)
        print("PER_CVE IN CVE_CALL: ", per_cve)
      except Exception as e:
        print("Error:", e)
        continue
    else:
      print("CVE not found")
  return details


### MAIN ###

# define nodes
# stream: head_node - > cve_node -> searchsploit_queries_node -> write_report_node

def head_node(state: AgentState):
  pingme = ping_test(state['ip'])
  return {"nmap_results": pingme}

def cve_node(state: AgentState):
  content = "\n\n".join(state["nmap_results"] or []) # joins list to make a string.
  user_message = HumanMessage(
      content = f" \n\nHere are the nmap scan results:\n\n{state['nmap_results']}")

  messages = [
      SystemMessage(
          content = cve_prompt.format(content=content)
          ),
      user_message
  ]

  response = llm.invoke(messages)
  print("llm agents response cves: ", response.content)
  CVE, cve_r = parse_cve(response.content) # returns list of cves, then list of lists of cve details
  myCVE = " ".join(CVE)
  cve_res = "\n".join([''.join(str(subl)) for subl in cve_r])
  return {"cves": myCVE,
          "cves_results": cve_res}


def write_report_node(state: AgentState):
  content = "\n\n".join(state['cves_results'] or [])
  user_message = HumanMessage(
      content = f"Here are the softwares: {state['cves']}"
  )
  messages = [
      SystemMessage(
          content = write_report_prompt.format(content=content)
      ),
      user_message
  ]
  response = llm.invoke(messages)
  print("\n\nREPORT FINAL NODE:\n", response.content)
  return{"report": response.content}

def end_node(state):
  return END

# conditional edge needed for some reason

def should_stop(state):
  return END

# BUILDER
builder = StateGraph(AgentState)

builder.add_node("head", head_node)
builder.add_node("cve", cve_node)
builder.add_node("write_report", write_report_node)
builder.add_node("end", end_node)

builder.set_entry_point("head")

# conditional
builder.add_conditional_edges(
    "write_report",
    should_stop,
    {END: END, "end": "end"})

# connect nodes

builder.add_edge("head", "cve")
builder.add_edge("cve", "write_report")

builder.add_edge("end", "write_report")

graph = builder.compile(checkpointer=memory)

# visual graph
# !apt install libgraphviz-dev
# !pip install pygraphviz
# from IPython.display import Image

# Image(graph.get_graph().draw_png())

# GRAPH STREAM
user_ip = input("enter the ip address or domain name to begin scanning: ")
thread = {"configurable": {"thread_id": "1"}}
for s in graph.stream({'ip': user_ip}, thread):
  print(s)
